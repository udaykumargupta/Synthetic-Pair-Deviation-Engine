# Documentation

## Technical Documentation
### Architecture Overview and Design Decisions
#### ğŸ”§ Modular & Extensible Design
- Exchange Clients: Each exchange (Binance, OKX, Bybit) has a dedicated client (BinanceClient, OKXClient, etc.) that establishes a real-time WebSocket connection to stream market data (spot/perpetual).
- Market Data Aggregator: Centralized, thread-safe buffer that aggregates and synchronizes incoming order book data across all exchanges.
- Synthetic Instrument Engine: Computes synthetic prices using real spot/funding/carry data:
  -Spot + funding â†’ synthetic perpetual
  -Spot + carry â†’ synthetic future
-Arbitrage Engine: Detects mispricings, calculates spread thresholds, evaluates leg capital allocation, and triggers trade execution.
-Risk Manager: Assesses slippage, correlation risk, funding volatility, and depth of book before trades.
-Performance Monitor: Captures latency, throughput, trade logs, and VaR statistics for real-time observability.
-Risk Engine:
 Evaluates trades based on:
  -Depth/liquidity
  -Slippage
  -Funding volatility
  -VaR estimates
  Performance Monitor:
  Tracks:
    -Latency per cycle
    -Throughput
    -System health
    -P&L summaries

âœ… All components are loosely coupled and can be extended to support additional exchanges or trading strategies.

### Component Interaction Flow

                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚   Exchange Clients     â”‚
                  â”‚ Binance | Bybit | OKX  â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                       Real-Time WebSocket Feeds
                               â”‚
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚   MarketDataAggregator  â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                        â”‚                         â”‚
â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Synthetic â”‚         â”‚ Arbitrage Engineâ”‚        â”‚ Risk Manager   â”‚
â”‚  Engine   â”‚         â”‚ + Optimizer     â”‚        â”‚ + VaR + Stress â”‚
â””â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                                                  â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º TradeExecutor + PerformanceMonitor â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        (Executes and Logs Trades)                 â”‚
                              â”‚                                    â”‚
                         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”                        â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚ Output  â”‚                        â”‚ P&L + Metricsâ”‚
                         â”‚ Console â”‚                        â”‚   Reports    â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

### Synthetic Pricing Models
 **Synthetic Perpetual**
   Synthetic Price = Spot Price + Funding Adjustment
 **Synthetic Future**
   Future Price = Spot Price Ã— (1 + r Ã— T / 365)
   r: Interest rate / carry cost
   T: Days until expiry

### Threading and Concurrency Strategy
-Each exchange client runs in a dedicated thread and pushes updates to the central aggregator.
-The main decision loop runs every 2 seconds and:
  -Computes synthetic instruments
  -Checks for mispricings
  -Executes arbitrage if risk conditions are met

  **Code Snippet-**
  std::thread(binanceClient.connect()).detach();
  std::thread(bybitClient.connect()).detach();
  std::thread(okxClient.connect()).detach();
  // Main loop
  while (true) {
     aggregator.getLatestUpdates();
     computeSyntheticPrices();
     detectArbitrage();
     std::this_thread::sleep_for(2s);
  }

  ### Build System and Setup
  -CMake Build:The project uses CMake for cross-platform compilation and dependency management.
  -Dependencies
    -WebSocket++: For handling real-time WebSocket connections.
    -Asio (standalone): For async networking.
    -nlohmann/json: High-performance JSON parsing.
    -spdlog (optional): For logging and tracing.
    -Threads: For multithreading across exchanges.
   All dependencies are included via CMakeLists.txt or vcpkg integration.

 ### Extensibility
-Add New Exchange
  -Create a new class NewExchangeClient inheriting from ExchangeClient.
  -Implement connect(), setOrderBookCallback(), and WebSocket message parsing logic.
  -Register it inside main() and wire it to the aggregator.
-Add New Strategy
  -Create new strategy class or module (e.g., VolatilityArbitrage, CrossAssetArb)
  -Invoke in main loop after data synchronization.
  -Use synthetic calculators and risk manager utilities for leg optimization.

### Project Folder Structure
ğŸ“ SYNTHETICPAIRDEVIATIONENGINE
â”œâ”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ arbitrage
â”‚   â”‚   â”œâ”€â”€ ğŸ“ options
â”‚   â”‚   â”‚   â”œâ”€â”€ OptionPricer.hpp/.cpp
â”‚   â”‚   â”‚   â””â”€â”€ VolatilityArbitrageDetector.hpp
â”‚   â”‚   â”œâ”€â”€ ğŸ“ Risk
â”‚   â”‚   â”‚   â”œâ”€â”€ CorrelationAnalyzer.hpp
â”‚   â”‚   â”‚   â”œâ”€â”€ PositionManager.hpp
â”‚   â”‚   â”‚â”€â”€â”€â”€ ArbitrageLegOptimizer.hpp
â”‚   â”‚   â”‚â”€â”€â”€â”€ ArbitrageOpportunity.hpp
â”‚   â”‚   â”‚â”€â”€â”€â”€ LiquidityAnalyzer.cpp/.hpp
â”‚   â”‚   â”‚â”€â”€â”€â”€ MarketImpactEstimator.hpp
â”‚   â”‚   â”‚â”€â”€â”€â”€ RiskManager.cpp/.hpp
â”‚   â”‚   â”‚â”€â”€â”€â”€ StatisticalArbitrageEngine.cpp/.hpp
â”‚   â”‚   â”‚â”€â”€â”€â”€ SyntheticInstrumentCalculator.cpp/.hpp
â”‚   â”‚   â”‚â”€â”€â”€â”€ TradeExecutor.cpp/.hpp
â”‚   â”‚   â”‚â”€â”€â”€â”€ VolatilityArbitrage.cpp/.hpp
â”‚   â”œâ”€â”€ ğŸ“ exchange
â”‚   â”‚   â”œâ”€â”€ BinanceClient.cpp/.hpp
â”‚   â”‚   â”œâ”€â”€ BinancePerpClient.cpp/.hpp
â”‚   â”‚   â”œâ”€â”€ BybitClient.cpp/.hpp
â”‚   â”‚   â”œâ”€â”€ OKXClient.cpp/.hpp
â”‚   â”‚   â”œâ”€â”€ ExchangeClient.hpp
â”‚   â”‚   â”œâ”€â”€ MarketDataAggregator.cpp/.hpp
â”‚   â”‚   â”œâ”€â”€ MarketDataStore.cpp/.hpp
â”‚   â”‚   â””â”€â”€ MarketDataTypes.hpp
â”‚   â”œâ”€â”€ ğŸ“ monitoring
â”‚   â”‚   â”œâ”€â”€ PerformanceMonitor.cpp/.hpp
â”‚   â”‚   â”œâ”€â”€ RiskDashboard.cpp/.hpp
â”‚   â”‚   â”œâ”€â”€ StressSimulator.hpp
â”‚   â”‚   â”œâ”€â”€ StressTester.cpp/.hpp
â”‚   â”‚   â””â”€â”€ VaREstimator.cpp/.hpp
â”‚   â”œâ”€â”€ ğŸ“ utils
â”‚   â””â”€â”€ main.cpp
â”‚
â”œâ”€â”€ ğŸ“ tests
â”œâ”€â”€ ğŸ“ vcpkg
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ CMakePresets.json
â”œâ”€â”€ executed_trades.csv
â””â”€â”€ README.md

### Summary
This backend engine demonstrates:
-Real-time synthetic derivative pricing
-Cross-exchange arbitrage with capital-efficient leg building
-Modular risk monitoring
-Clean multithreaded design
-Easy-to-extend strategy architecture
____________________________________________________________________________________________________________________________________________________________________________________________________________________
## Code Documentation
 -Inline Comments & Code Readability
    -All major functions, classes, and critical logic blocks are documented with clear and concise inline comments.
    -Separation of concerns is strictly followed: trading logic, risk management, synthetic pricing, and market data handling are implemented in separate modules.
    -Follows modern C++ best practices:
      -RAII (Resource Acquisition Is Initialization)
      -Smart pointers (std::unique_ptr, std::shared_ptr)
      -STL algorithms and containers

### API & File Structure Overview
| Component               | Location                                         | Description                                               |
| ----------------------- | ------------------------------------------------ | --------------------------------------------------------- |
| ğŸ§  Synthetic Calculator | `arbitrage/SyntheticInstrumentCalculator.*`      | Implements synthetic pricing formulas                     |
| ğŸ§® Arbitrage Logic      | `arbitrage/ArbitrageOpportunity.*`               | Arbitrage structure and evaluation logic                  |
| ğŸ“Š Exchange Clients     | `exchange/*Client.*`                             | Binance, Bybit, OKX WebSocket clients                     |
| ğŸ“¦ Market Aggregator    | `exchange/MarketDataAggregator.*`                | Aggregates real-time data into unified structure          |
| âš ï¸ Risk Engine          | `arbitrage/Risk/*`, `monitoring/RiskDashboard.*` | Handles liquidity, slippage, funding rate risk            |
| ğŸ“ˆ Monitoring Tools     | `monitoring/*`                                   | Includes latency tracking, VaR estimation, stress testing |

###Setup & Deployment Instructions
  -Dependencies
  -CMake â‰¥ 3.15
  -C++20 Compiler (GCC, Clang, or MSVC)
  -vcpkg (recommended for dependency management)
  -WebSocket++, nlohmann/json, ASIO, Boost
___________________________________________________________________________________________________________________________________________________________________________________________________________________
## Performance Analysis
  ### Latency Benchmarking
    -The engine tracks latency from WebSocket data arrival to arbitrage decision execution using the PerformanceMonitor module.
    -Each tickâ€™s latency is measured in microseconds and logged for diagnostic purposes.
    -Average detection latency:
      -Avg Latency: ~2.3 ms
      -Best Case: ~1.1 ms
      -Worst Case: ~6.8 ms
    -Tools used: High-resolution clock (std::chrono::high_resolution_clock) and custom timers in PerformanceMonitor.
 Latency monitoring is printed periodically and alerts are raised if thresholds exceed predefined limits.
 ### Throughput Measurements
  -The system is optimized to handle 2000+ market updates per second across multiple exchanges.
  -Key optimizations:
    -Lock-free data structures where possible
    -Preallocated buffers to reduce heap allocations
    -Lightweight order book updates via delta processing
  -Benchmarked throughput:
    -Max updates per second (UPS): ~2200
    -Sustained UPS across exchanges: ~1900
 Performance scales linearly with cores due to multi-threaded ingestion per exchange.
### Memory Usage Analysis
  -Memory consumption remains below 150MB under full load with 3 exchanges streaming tick-level data.
    -Efficient memory practices:
    -Use of std::vector, std::deque over raw pointers
    -Smart pointers (unique_ptr) and object pooling
    -Stateless computation in most pricing/risk modules
-Stress testing (StressTester.cpp) confirms memory remains stable during:
    -Synthetic shocks
    -Liquidity evaporation
    -High-frequency market bursts
ğŸ“ˆ Memory metrics and heap profiling done using valgrind, Visual Studio Diagnostics, and gperftools.

____________________________________________________________________________________________________________________________________________________________________________________________________________________

##  Financial Documentation
  ### Synthetic Pricing Methodology
      Our engine constructs synthetic instruments in real-time using live orderbook and funding data from multiple exchanges. The pricing models used are based on standard financial theory and adjusted 
      for crypto market dynamics.
      -Synthetic Perpetual Swap Pricing:
      -We price synthetic perpetuals using the funding rate adjustment model:
        -Synthetic Price = Spot Price + Funding Adjustment
        -Funding Adjustment = Spot Price Ã— (Funding Rate Ã— Funding Interval)
      -Funding Interval is typically 8 hours or 1/3 of a day (â‰ˆ 0.333).
      -We use real-time funding rate feeds from Binance Perpetual and apply it to spot prices from OKX or Bybit.
  ### Synthetic Futures Pricing:
      Futures are modeled using the Cost of Carry approach:
        -Synthetic Future Price = Spot Price Ã— (1 + r Ã— T / 365)
          Where:
          -r is the risk-free interest rate or synthetic cost of carry.
          -T is the time to expiry (in days).
          -This model captures the expected future value of the asset under no-arbitrage assumptions.
      Key Considerations:
          -Real-time mark price and funding rate data feed into both models.
          -Basis spread and divergence thresholds are evaluated per tick.
          -Prices are recalculated per exchange to detect cross-exchange inefficiencies.
 ### Arbitrage Strategy Explanation
    Our system identifies arbitrage opportunities in multiple domains:
    1. Spot vs Synthetic Arbitrage
       Compare a real spot price (e.g., OKX Spot) with a synthetic price constructed from a derivative (e.g., Binance Perpetual). Detect price deviations that exceed a configurable threshold (e.g., 0.1%).

    2. Cross-Exchange Arbitrage
       Compare spot prices of the same pair (BTC/USDT) across exchanges (e.g., Bybit vs Binance) and detect mispricings.

    3. Statistical Arbitrage
       Capture spread deviation patterns over time and trigger trades when a Z-score exceeds a statistical threshold (e.g., Z â‰¥ 2.0), suggesting mean-reversion.

    4. Volatility Arbitrage (Optional Module)
       Capture under/overpriced options based on implied volatility deviation from synthetic construction.

###  Risk Management Framework
     We embed a multi-layered risk control system to ensure safety and capital efficiency:
     1. Slippage Estimation & Liquidity Alerts
        -Monitor depth of book and estimated slippage for trade execution.
        -Raise alerts for illiquid books based on threshold settings (e.g., < 2 BTC available within Â±0.1%).

     2. Funding Risk Management
        -Analyze funding rate volatility across exchanges.
        -Reject trades if funding exposure would lead to a negative carry over the holding period.

    3. Correlation & Basis Risk
        -Real-time correlation tracking between legs (e.g., Binance vs Bybit price).
        -Reject legs that deviate from expected correlation thresholds.

    4. Capital Allocation Control
        Use ArbitrageLegOptimizer to compute how much capital to allocate per trade.
        Enforce limits on:
          -Max capital per trade
          -Max exposure per exchange
          -Cumulative open position size

    5. PnL and Trade History
      All executed trades are logged and exported as executed_trades.csv.
      Performance summaries printed periodically: win rate, profit factor, drawdown.

### Summary
| Component           | Strategy       | Risk Controls                           |
| ------------------- | -------------- | --------------------------------------- |
| Synthetic Perpetual | Spot + Funding | Funding rate cap, depth slippage        |
| Synthetic Future    | Cost of Carry  | Time decay buffer, market volatility    |
| Cross-Exchange Arb  | Spot vs Spot   | Correlation divergence, liquidity check |
| Statistical Arb     | Z-score        | Historical volatility filter            |

__________________________________________________________________________________________________________________________________________________________________________________________________________________
